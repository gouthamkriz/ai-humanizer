<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Text Humanizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .scrollbar-custom::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .scrollbar-custom::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }
        .scrollbar-custom::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 10px;
        }
        .scrollbar-custom::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            backdrop-filter: blur(2px);
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            width: 0%;
            transition: width 0.3s ease;
        }
        .feature-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .humanization-level {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }
        .stats-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen py-6 px-4">

    <div class="max-w-7xl w-full mx-auto space-y-8">
        <!-- Header -->
        <div class="text-center bg-white p-8 rounded-2xl shadow-lg">
            <h1 class="text-5xl font-bold text-gray-900 mb-4 bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                Advanced AI Text Humanizer
            </h1>
            <p class="text-xl text-gray-600 max-w-3xl mx-auto">
                Transform AI-generated content into naturally flowing, human-like text that passes plagiarism detection with advanced processing techniques.
            </p>
        </div>

        <!-- Control Panel -->
        <div class="bg-white p-6 rounded-2xl shadow-lg">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Humanization Settings</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="humanization-level p-4 rounded-lg">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Humanization Level</label>
                    <select id="humanizationLevel" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <option value="moderate">Moderate (Balanced)</option>
                        <option value="aggressive" selected>Aggressive (Maximum Change)</option>
                        <option value="conservative">Conservative (Minimal Change)</option>
                    </select>
                </div>
                <div class="stats-card p-4 rounded-lg">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Writing Style</label>
                    <select id="writingStyle" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                        <option value="academic" selected>Academic (Scholarly)</option>
                        <option value="conversational">Conversational Academic</option>
                        <option value="professional">Professional Academic</option>
                        <option value="technical">Technical Academic</option>
                        <option value="creative">Creative Academic</option>
                    </select>
                </div>
                <div class="feature-card p-4 rounded-lg">
                    <label class="flex items-center">
                        <input type="checkbox" id="multiPass" class="mr-2" checked>
                        <span class="text-sm font-medium">Multi-Pass Processing</span>
                    </label>
                    <p class="text-xs mt-1 opacity-90">Process text multiple times for better results</p>
                </div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Input Panel -->
            <div class="bg-white p-6 rounded-2xl shadow-lg flex flex-col">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Input Text</h2>
                <div class="mb-4 relative">
                    <label for="file-upload" id="file-upload-label" class="flex items-center justify-center w-full px-4 py-3 border-2 border-dashed border-gray-300 rounded-lg text-sm font-medium text-gray-600 bg-gray-50 hover:bg-gray-100 hover:border-blue-400 focus-within:ring-2 focus-within:ring-blue-500 cursor-pointer transition-all duration-200">
                        <svg id="upload-icon" class="w-6 h-6 mr-2 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <div id="upload-spinner" class="hidden animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500 mr-2"></div>
                        <span id="upload-text">Upload Document (.docx, .doc, .txt)</span>
                        <input id="file-upload" type="file" class="sr-only" accept=".doc,.docx,.txt">
                    </label>
                    
                    <!-- File Upload Progress Bar -->
                    <div id="file-progress" class="hidden mt-2">
                        <div class="flex items-center justify-between text-sm text-gray-600 mb-1">
                            <span id="file-status">Processing...</span>
                            <span id="file-size"></span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2">
                            <div id="file-progress-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="flex-1 flex flex-col">
                    <textarea id="inputText" class="flex-1 min-h-96 w-full border border-gray-300 p-4 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none text-gray-700 scrollbar-custom" placeholder="Paste your AI-generated text here for humanization... (Optimal: 2000-5000 words | Max: ~10,000 words)"></textarea>
                    <div class="mt-2 text-sm text-gray-500">
                        <span id="inputWordCount">0 words</span> | <span id="inputCharCount">0 characters</span>
                    </div>
                </div>
            </div>

            <!-- Output Panel -->
            <div class="relative bg-white p-6 rounded-2xl shadow-lg flex flex-col">
                <div id="loading-overlay" class="loading-overlay rounded-2xl">
                    <div class="text-center">
                        <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
                        <p class="text-gray-600 font-medium" id="loadingText">Humanizing text...</p>
                        <div class="progress-bar mt-4 max-w-xs mx-auto">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <p class="text-sm text-gray-500 mt-2" id="progressText">Initializing...</p>
                    </div>
                </div>
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Humanized Text</h2>
                <div class="flex-1 flex flex-col">
                    <textarea id="outputText" class="flex-1 min-h-96 w-full border border-gray-300 p-4 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none text-gray-700 scrollbar-custom" placeholder="Humanized text will appear here..." readonly></textarea>
                    <div class="mt-2 flex justify-between text-sm text-gray-500">
                        <div>
                            <span id="outputWordCount">0 words</span> | <span id="outputCharCount">0 characters</span>
                        </div>
                        <div id="humanizationScore" class="font-medium text-green-600"></div>
                    </div>
                </div>
                <div class="flex flex-wrap gap-2 mt-4">
                    <button id="copyButton" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg transition-colors duration-200">
                        <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        Copy
                    </button>
                    <button id="downloadDocButton" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200">
                        <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        DOC
                    </button>
                    <button id="downloadPdfButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200">
                        <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        PDF
                    </button>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
            <button id="humanizeButton" class="px-8 py-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-bold rounded-xl shadow-lg hover:from-blue-700 hover:to-purple-700 transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                üöÄ Humanize Text
            </button>
            <button id="clearButton" class="px-8 py-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold rounded-xl shadow-lg transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                üóëÔ∏è Clear All
            </button>
        </div>

        <!-- Tips Section -->
        <div class="bg-white p-6 rounded-2xl shadow-lg">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">üí° Tips for Better Results</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="p-4 bg-blue-50 rounded-lg">
                    <h4 class="font-medium text-blue-900 mb-2">Academic Quality</h4>
                    <p class="text-sm text-blue-700">Default academic style maintains scholarly rigor while humanizing AI-typical academic phrases and patterns.</p>
                </div>
                <div class="p-4 bg-green-50 rounded-lg">
                    <h4 class="font-medium text-green-900 mb-2">Scholarly Standards</h4>
                    <p class="text-sm text-green-700">Preserves citations, references, and academic integrity while creating natural scholarly voice and flow.</p>
                </div>
                <div class="p-4 bg-purple-50 rounded-lg">
                    <h4 class="font-medium text-purple-900 mb-2">Academic Formatting</h4>
                    <p class="text-sm text-purple-700">Maintains disciplinary conventions, academic structure, and formal discourse standards throughout.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed top-6 right-6 z-50 transform translate-x-full transition-transform duration-300">
        <div id="toast-content" class="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg flex items-center">
            <span id="toast-message"></span>
        </div>
    </div>

    <script>
        class TextHumanizer {
            constructor() {
                // this.apiKey = "";
                this.backendUrl = "https://ai-humanizer-ue4z.onrender.com/"; // Render URL
                this.apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${this.apiKey}`;
                this.initializeElements();
                this.attachEventListeners();
            }

            initializeElements() {
                this.elements = {
                    fileUpload: document.getElementById('file-upload'),
                    fileUploadLabel: document.getElementById('file-upload-label'),
                    uploadIcon: document.getElementById('upload-icon'),
                    uploadSpinner: document.getElementById('upload-spinner'),
                    uploadText: document.getElementById('upload-text'),
                    fileProgress: document.getElementById('file-progress'),
                    fileStatus: document.getElementById('file-status'),
                    fileSize: document.getElementById('file-size'),
                    fileProgressBar: document.getElementById('file-progress-bar'),
                    inputText: document.getElementById('inputText'),
                    outputText: document.getElementById('outputText'),
                    humanizeButton: document.getElementById('humanizeButton'),
                    clearButton: document.getElementById('clearButton'),
                    copyButton: document.getElementById('copyButton'),
                    downloadDocButton: document.getElementById('downloadDocButton'),
                    downloadPdfButton: document.getElementById('downloadPdfButton'),
                    loadingOverlay: document.getElementById('loading-overlay'),
                    humanizationLevel: document.getElementById('humanizationLevel'),
                    writingStyle: document.getElementById('writingStyle'),
                    multiPass: document.getElementById('multiPass'),
                    inputWordCount: document.getElementById('inputWordCount'),
                    inputCharCount: document.getElementById('inputCharCount'),
                    outputWordCount: document.getElementById('outputWordCount'),
                    outputCharCount: document.getElementById('outputCharCount'),
                    humanizationScore: document.getElementById('humanizationScore'),
                    progressFill: document.getElementById('progressFill'),
                    progressText: document.getElementById('progressText'),
                    loadingText: document.getElementById('loadingText')
                };
            }

            attachEventListeners() {
                this.elements.fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
                this.elements.inputText.addEventListener('input', () => this.updateWordCount('input'));
                this.elements.outputText.addEventListener('input', () => this.updateWordCount('output'));
                this.elements.humanizeButton.addEventListener('click', () => this.humanizeText());
                this.elements.clearButton.addEventListener('click', () => this.clearAll());
                this.elements.copyButton.addEventListener('click', () => this.copyToClipboard());
                this.elements.downloadDocButton.addEventListener('click', () => this.downloadDoc());
                this.elements.downloadPdfButton.addEventListener('click', () => this.downloadPdf());
            }

            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                const toastMessage = document.getElementById('toast-message');
                toastMessage.textContent = message;
                
                toast.classList.remove('translate-x-full');
                setTimeout(() => {
                    toast.classList.add('translate-x-full');
                }, 4000);
            }

            updateWordCount(type) {
                const textArea = type === 'input' ? this.elements.inputText : this.elements.outputText;
                const wordCountEl = type === 'input' ? this.elements.inputWordCount : this.elements.outputWordCount;
                const charCountEl = type === 'input' ? this.elements.inputCharCount : this.elements.outputCharCount;
                
                const text = textArea.value;
                const words = text.trim().split(/\s+/).filter(word => word.length > 0).length;
                const chars = text.length;
                
                wordCountEl.textContent = `${words} words`;
                charCountEl.textContent = `${chars} characters`;
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Start loading state
                this.setFileUploadState(true);
                
                const fileName = file.name.toLowerCase();
                const fileExtension = fileName.split('.').pop();
                const fileSizeKB = Math.round(file.size / 1024);
                const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
                
                // Update file info
                this.elements.fileSize.textContent = fileSizeKB > 1024 ? `${fileSizeMB} MB` : `${fileSizeKB} KB`;
                this.elements.fileStatus.textContent = 'Reading file...';
                this.updateFileProgress(10);

                try {
                    let content = '';
                    
                    if (fileExtension === 'docx') {
                        this.elements.fileStatus.textContent = 'Processing Word document (.docx)...';
                        this.updateFileProgress(30);
                        
                        try {
                            const arrayBuffer = await this.readFileAsArrayBuffer(file);
                            this.updateFileProgress(60);
                            
                            // Check if mammoth is loaded
                            if (typeof mammoth === 'undefined') {
                                throw new Error('Document processor not loaded. Please refresh the page.');
                            }
                            
                            const result = await mammoth.extractRawText({ arrayBuffer });
                            content = result.value || '';
                            this.updateFileProgress(85);
                            
                            // Log any messages from mammoth
                            if (result.messages && result.messages.length > 0) {
                                console.log('Mammoth messages:', result.messages);
                            }
                            
                        } catch (docError) {
                            console.error('DOCX processing error:', docError);
                            throw new Error('Failed to process Word document. Please ensure it\'s a valid .docx file.');
                        }
                        
                    } else if (fileExtension === 'doc') {
                        this.elements.fileStatus.textContent = 'Processing legacy Word document (.doc)...';
                        this.updateFileProgress(30);
                        
                        // For .doc files, try to read as text (limited support)
                        try {
                            const text = await this.readFileAsText(file);
                            // Basic cleanup for .doc files read as text
                            content = text.replace(/[^\x20-\x7E\n\r\t]/g, ' ').replace(/\s+/g, ' ').trim();
                            this.updateFileProgress(85);
                            
                            if (!content) {
                                throw new Error('Could not extract text from .doc file');
                            }
                        } catch (docError) {
                            console.error('DOC processing error:', docError);
                            throw new Error('Legacy .doc format has limited support. Please save as .docx or .txt for best results.');
                        }
                        
                    } else if (fileExtension === 'txt') {
                        this.elements.fileStatus.textContent = 'Processing text file...';
                        this.updateFileProgress(30);
                        
                        try {
                            content = await this.readFileAsText(file);
                            this.updateFileProgress(85);
                        } catch (txtError) {
                            console.error('TXT processing error:', txtError);
                            throw new Error('Failed to read text file.');
                        }
                        
                    } else {
                        throw new Error(`Unsupported file format: .${fileExtension}. Please use .docx, .doc, or .txt files.`);
                    }

                    // Validate content
                    if (!content || content.trim().length === 0) {
                        throw new Error('The uploaded file appears to be empty or contains no readable text.');
                    }

                    // Check content length and provide realistic warnings
                    if (content.length > 100000) {
                        this.showToast('‚ö†Ô∏è Very large file. For best results, consider processing in sections of 2000-3000 words.');
                    } else if (content.length > 50000) {
                        this.showToast('‚ö†Ô∏è Large file detected. Processing may take 1-2 minutes.');
                    }

                    this.elements.fileStatus.textContent = 'File loaded successfully!';
                    this.updateFileProgress(100);

                    // Populate the text area
                    this.elements.inputText.value = content.trim();
                    this.updateWordCount('input');
                    
                    const wordCount = content.trim().split(/\s+/).filter(word => word.length > 0).length;
                    
                    // Success feedback
                    this.showToast(`‚úÖ File loaded successfully! (${wordCount} words, ${content.length} characters)`);
                    
                    // Hide progress after a moment and show success state
                    setTimeout(() => {
                        this.setFileUploadState(false);
                        this.elements.uploadText.textContent = `‚úÖ ${file.name}`;
                        this.elements.fileUploadLabel.classList.add('border-green-300', 'bg-green-50');
                        this.elements.fileUploadLabel.classList.remove('border-gray-300', 'bg-gray-50');
                    }, 1500);

                } catch (error) {
                    console.error('File processing error:', error);
                    this.elements.fileStatus.textContent = error.message || 'Failed to process file';
                    this.updateFileProgress(0);
                    this.setFileUploadState(false);
                    this.showToast(`‚ùå ${error.message || 'Failed to read file. Please try a different file.'}`);
                    
                    // Reset file input
                    this.elements.fileUpload.value = '';
                }
            }

            // Helper method to read file as ArrayBuffer
            readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file as ArrayBuffer'));
                    reader.readAsArrayBuffer(file);
                });
            }

            // Helper method to read file as Text
            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file as text'));
                    reader.readAsText(file, 'UTF-8');
                });
            }

            setFileUploadState(loading) {
                if (loading) {
                    this.elements.uploadIcon.classList.add('hidden');
                    this.elements.uploadSpinner.classList.remove('hidden');
                    this.elements.uploadText.textContent = 'Processing file...';
                    this.elements.fileProgress.classList.remove('hidden');
                    this.elements.fileUpload.disabled = true;
                    this.elements.fileUploadLabel.style.pointerEvents = 'none';
                } else {
                    this.elements.uploadIcon.classList.remove('hidden');
                    this.elements.uploadSpinner.classList.add('hidden');
                    this.elements.fileProgress.classList.add('hidden');
                    this.elements.fileUpload.disabled = false;
                    this.elements.fileUploadLabel.style.pointerEvents = 'auto';
                    this.updateFileProgress(0);
                }
            }

            updateFileProgress(percentage) {
                this.elements.fileProgressBar.style.width = `${percentage}%`;
            }

            getAdvancedPrompt(text, level, style, passNumber = 1) {
                const levelInstructions = {
                    conservative: "Make minimal but effective changes to improve naturalness while preserving the original academic structure and scholarly tone.",
                    moderate: "Restructure sentences moderately, vary academic vocabulary, and improve scholarly flow while maintaining rigorous academic standards.",
                    aggressive: "Completely rewrite the content with new academic sentence structures, diverse scholarly vocabulary, natural academic transitions, and human-like academic expressions while preserving all key information and citations."
                };

                const styleInstructions = {
                    conversational: "Use an approachable academic tone with clear explanations while maintaining scholarly credibility and appropriate formality.",
                    academic: "Maintain rigorous scholarly tone with precise academic language, clear evidence-based arguments, proper academic structure, and formal discourse conventions.",
                    professional: "Use professional academic language that's clear, authoritative, and suitable for academic or research contexts.",
                    creative: "Employ engaging academic language with vivid scholarly metaphors and imaginative academic expressions while maintaining academic rigor.",
                    technical: "Use precise academic and technical terminology while ensuring clarity, logical academic flow, and scholarly precision."
                };

                const passInstructions = passNumber > 1 ? 
                    "This is a second pass - further refine the academic text to make it even more naturally scholarly and human-like. Focus on eliminating any remaining AI-like academic patterns while preserving academic integrity." : 
                    "Transform this AI-generated academic text into naturally flowing, human-written scholarly content that maintains academic standards.";

                const academicFocus = `
ACADEMIC WRITING REQUIREMENTS:
1. Maintain scholarly rigor and academic integrity throughout
2. Use varied academic vocabulary and sophisticated sentence structures
3. Employ critical analysis and evidence-based reasoning
4. Include natural academic transitions and connecting arguments
5. Preserve all citations, references, and academic formatting
6. Use active and passive voice appropriately for academic context
7. Maintain formal academic tone while adding human scholarly voice
8. Include nuanced academic arguments and balanced perspectives
9. Ensure logical academic flow and coherent argument development
10. Add scholarly depth and academic sophistication`;

                return `${passInstructions}

CRITICAL ACADEMIC HUMANIZATION REQUIREMENTS:
1. ${levelInstructions[level]}
2. ${styleInstructions[style]}
${academicFocus}

ELIMINATE AI-TYPICAL ACADEMIC PHRASES:
- Replace "delve into" with "examine", "explore", "investigate", "analyze"
- Replace "it's important to note" with "significantly", "notably", "crucially"  
- Replace "furthermore/moreover" with "additionally", "in addition", "building on this"
- Replace "in conclusion" with "ultimately", "in summary", "these findings suggest"
- Replace "comprehensive analysis" with "thorough examination", "detailed investigation"
- Replace "significant implications" with "important consequences", "notable effects"
- Replace "robust framework" with "solid foundation", "strong theoretical base"
- Replace "utilize" with "use", "employ", "apply"
- Replace "facilitate" with "enable", "support", "promote"

ADD NATURAL ACADEMIC ELEMENTS:
- Scholarly personal insights and academic observations
- Varied sentence lengths appropriate for academic discourse
- Natural academic transitions between complex ideas
- Critical questioning and academic skepticism where appropriate
- Balanced academic arguments with multiple perspectives
- Scholarly synthesis of ideas and concepts
- Academic voice that shows expertise and understanding
- Natural flow between theoretical and practical applications
- Appropriate academic hedging (may, might, appears to, suggests)
- Scholarly connections between different concepts and studies

ACADEMIC WRITING STYLE:
- Use discipline-appropriate terminology naturally
- Employ sophisticated but clear sentence structures
- Maintain objectivity while allowing scholarly interpretation
- Include appropriate academic modality and hedging
- Use varied citation integration methods naturally
- Balance complexity with clarity for academic audience
- Show deep understanding through natural scholarly analysis
- Demonstrate critical thinking through argument development

PRESERVE ACADEMIC INTEGRITY:
- Maintain all factual accuracy and scholarly claims
- Preserve citations, references, and academic sources exactly
- Keep academic formatting and structural elements
- Maintain disciplinary conventions and standards
- Preserve technical accuracy and scholarly precision

AVOID: Any introductory remarks, meta-commentary, explanations, or non-academic language. Provide ONLY the rewritten academic content that maintains scholarly standards while being naturally human-written.

Original academic text:
${text}`;
            }

            async callGeminiAPI(prompt, retries = 0) {
                const maxRetries = 3; // Reduced retries to avoid long waits
                const baseDelay = 2000; // Increased base delay

                try {
                    // Limit prompt length to avoid timeouts
                    const maxPromptLength = 15000; // Reasonable limit
                    const truncatedPrompt = prompt.length > maxPromptLength ? 
                        prompt.substring(0, maxPromptLength) + "\n\n[Content truncated for processing]" : prompt;

                    const response = await fetch("http://127.0.0.1:8000/humanize", {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: truncatedPrompt }] }],
                            generationConfig: {
                                temperature: 0.8, // Slightly reduced for more consistent output
                                topK: 40,
                                topP: 0.9,
                                maxOutputTokens: 4096 // Reduced to prevent timeouts
                            },
                            safetySettings: [
                                {
                                    category: "HARM_CATEGORY_HARASSMENT",
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                },
                                {
                                    category: "HARM_CATEGORY_HATE_SPEECH", 
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                },
                                {
                                    category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                },
                                {
                                    category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                                    threshold: "BLOCK_MEDIUM_AND_ABOVE"
                                }
                            ]
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
                            return result.candidates[0].content.parts[0].text.trim();
                        }
                        throw new Error('Invalid API response structure');
                    }

                    if (response.status === 429 && retries < maxRetries) {
                        const delay = baseDelay * Math.pow(2, retries);
                        this.elements.progressText.textContent = `Rate limited. Waiting ${Math.ceil(delay/1000)}s...`;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return this.callGeminiAPI(prompt, retries + 1);
                    }

                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                } catch (error) {
                    if (error.name === 'AbortError' || error.message.includes('timeout')) {
                        throw new Error('Connection timeout - try smaller text sections');
                    }
                    
                    if (retries < maxRetries) {
                        const delay = baseDelay * Math.pow(2, retries);
                        this.elements.progressText.textContent = `Connection error. Retrying in ${Math.ceil(delay/1000)}s...`;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return this.callGeminiAPI(prompt, retries + 1);
                    }
                    throw error;
                }
            }

            async humanizeText() {
                const inputContent = this.elements.inputText.value.trim();
                if (!inputContent) {
                    this.showToast('Please enter or upload some text first.');
                    return;
                }

                // Increased limits for larger documents
                if (inputContent.length > 200000) { // Increased from 50,000 to 200,000 characters
                    this.showToast('Text is too long. Please use content under 200,000 characters (~40,000 words).');
                    return;
                }

                const wordCount = inputContent.split(/\s+/).filter(word => word.length > 0).length;
                
                // Handle very large texts by processing in chunks if needed
                if (wordCount > 15000) {
                    const shouldProcess = confirm(`This is a large document (${wordCount} words). Processing may take 2-3 minutes. Continue?`);
                    if (!shouldProcess) return;
                }

                this.setLoadingState(true);
                
                try {
                    const level = this.elements.humanizationLevel.value;
                    const style = this.elements.writingStyle.value;
                    const multiPass = this.elements.multiPass.checked;

                    this.updateProgress(5, 'Analyzing input text...');
                    
                    let result = '';
                    
                    // For very large texts, process in chunks
                    if (wordCount > 8000) {
                        result = await this.processLargeText(inputContent, level, style, multiPass);
                    } else {
                        // Regular processing for smaller texts
                        this.updateProgress(20, 'First pass: Restructuring content...');
                        const firstPassPrompt = this.getAdvancedPrompt(inputContent, level, style, 1);
                        result = await this.callGeminiAPI(firstPassPrompt);

                        if (multiPass && result) {
                            this.updateProgress(60, 'Second pass: Refining naturalness...');
                            const secondPassPrompt = this.getAdvancedPrompt(result, level, style, 2);
                            const secondResult = await this.callGeminiAPI(secondPassPrompt);
                            if (secondResult) result = secondResult;
                        }
                    }

                    this.updateProgress(95, 'Finalizing...');

                    if (result) {
                        this.elements.outputText.value = result;
                        this.updateWordCount('output');
                        this.calculateHumanizationScore(inputContent, result);
                        this.showToast(`üéâ Text humanized successfully! (${result.split(/\s+/).length} words processed)`);
                    } else {
                        throw new Error('Failed to generate humanized content');
                    }

                } catch (error) {
                    console.error('Humanization error:', error);
                    this.showToast('An error occurred. For large texts, try breaking them into smaller sections.');
                    this.elements.outputText.value = "Error: Could not process the text. For very large documents, try processing in smaller sections.";
                } finally {
                    this.setLoadingState(false);
                }
            }

            // New method to handle large text processing
            async processLargeText(text, level, style, multiPass) {
                const words = text.split(/\s+/);
                const chunkSize = 3000; // Process in chunks of ~3000 words
                const chunks = [];
                
                // Split into chunks
                for (let i = 0; i < words.length; i += chunkSize) {
                    chunks.push(words.slice(i, i + chunkSize).join(' '));
                }
                
                this.updateProgress(10, `Processing ${chunks.length} sections...`);
                
                const processedChunks = [];
                
                for (let i = 0; i < chunks.length; i++) {
                    const progress = 10 + (i / chunks.length) * (multiPass ? 40 : 80);
                    this.updateProgress(progress, `Processing section ${i + 1} of ${chunks.length}...`);
                    
                    const prompt = this.getAdvancedPrompt(chunks[i], level, style, 1);
                    const result = await this.callGeminiAPI(prompt);
                    
                    if (result) {
                        processedChunks.push(result);
                    } else {
                        processedChunks.push(chunks[i]); // Fallback to original if processing fails
                    }
                    
                    // Small delay between chunks to avoid rate limiting
                    if (i < chunks.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                let finalResult = processedChunks.join('\n\n');
                
                // Optional second pass for large documents (only if multiPass is enabled and result isn't too long)
                if (multiPass && finalResult.length < 100000) {
                    this.updateProgress(70, 'Second pass: Final refinement...');
                    
                    // For second pass, process the entire result if it's not too long
                    const secondPassPrompt = this.getAdvancedPrompt(finalResult, level, style, 2);
                    const secondResult = await this.callGeminiAPI(secondPassPrompt);
                    
                    if (secondResult) {
                        finalResult = secondResult;
                    }
                }
                
                return finalResult;
            }

            calculateHumanizationScore(original, humanized) {
                const originalWords = original.toLowerCase().split(/\s+/);
                const humanizedWords = humanized.toLowerCase().split(/\s+/);
                
                // Simple similarity calculation (inverse of Jaccard similarity)
                const originalSet = new Set(originalWords);
                const humanizedSet = new Set(humanizedWords);
                const intersection = new Set([...originalSet].filter(x => humanizedSet.has(x)));
                const union = new Set([...originalSet, ...humanizedSet]);
                
                const similarity = intersection.size / union.size;
                const humanizationScore = Math.round((1 - similarity) * 100);
                
                this.elements.humanizationScore.textContent = `Humanization: ${Math.max(humanizationScore, 15)}%`;
            }

            updateProgress(percentage, text) {
                this.elements.progressFill.style.width = `${percentage}%`;
                this.elements.progressText.textContent = text;
            }

            setLoadingState(loading) {
                const buttons = [
                    this.elements.humanizeButton,
                    this.elements.clearButton,
                    this.elements.copyButton,
                    this.elements.downloadDocButton,
                    this.elements.downloadPdfButton
                ];
                
                buttons.forEach(btn => btn.disabled = loading);
                this.elements.loadingOverlay.style.display = loading ? 'flex' : 'none';
                
                if (!loading) {
                    this.updateProgress(0, 'Ready');
                }
            }

            clearAll() {
                this.elements.inputText.value = '';
                this.elements.outputText.value = '';
                this.elements.humanizationScore.textContent = '';
                this.updateWordCount('input');
                this.updateWordCount('output');
                
                // Reset file upload state
                this.elements.uploadText.textContent = 'Upload Document (.docx, .doc, .txt)';
                this.elements.fileUploadLabel.classList.remove('border-green-300', 'bg-green-50');
                this.elements.fileUploadLabel.classList.add('border-gray-300', 'bg-gray-50');
                this.elements.fileUpload.value = ''; // Clear file input
                
                this.showToast('Content cleared.');
            }

            async copyToClipboard() {
                if (!this.elements.outputText.value.trim()) {
                    this.showToast('No text to copy!');
                    return;
                }

                try {
                    await navigator.clipboard.writeText(this.elements.outputText.value);
                    this.showToast('Copied to clipboard! üìã');
                } catch (err) {
                    this.elements.outputText.select();
                    document.execCommand('copy');
                    this.showToast('Copied to clipboard! üìã');
                }
            }

            downloadDoc() {
                const content = this.elements.outputText.value;
                if (!content.trim()) {
                    this.showToast('No text to download!');
                    return;
                }

                const blob = new Blob([content], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `humanized-text-${new Date().toISOString().slice(0, 10)}.doc`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showToast('Document downloaded! üìÑ');
            }

            downloadPdf() {
                const content = this.elements.outputText.value;
                if (!content.trim()) {
                    this.showToast('No text to download!');
                    return;
                }

                // Create a styled div for PDF generation
                const tempDiv = document.createElement('div');
                tempDiv.style.cssText = `
                    padding: 40px;
                    font-family: 'Georgia', serif;
                    font-size: 12px;
                    line-height: 1.6;
                    color: #333;
                    max-width: 800px;
                    margin: 0 auto;
                `;
                
                // Convert line breaks to paragraphs
                const paragraphs = content.split('\n\n').filter(p => p.trim());
                paragraphs.forEach(paragraph => {
                    const p = document.createElement('p');
                    p.style.marginBottom = '16px';
                    p.textContent = paragraph.trim();
                    tempDiv.appendChild(p);
                });

                document.body.appendChild(tempDiv);

                const options = {
                    margin: [0.5, 0.5, 0.5, 0.5],
                    filename: `humanized-text-${new Date().toISOString().slice(0, 10)}.pdf`,
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 2, useCORS: true },
                    jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
                };

                html2pdf().set(options).from(tempDiv).save().finally(() => {
                    document.body.removeChild(tempDiv);
                    this.showToast('PDF downloaded! üìë');
                });
            }
        }

            // Enhanced academic text processing utilities
        class AcademicTextAnalyzer {
            static detectAcademicAIPatterns(text) {
                const academicAIPatterns = [
                    // Common AI academic phrases
                    /\b(delve into|delves into|delving into)\b/gi,
                    /\b(it'?s important to note|it should be noted|it is worth noting)\b/gi,
                    /\b(furthermore|moreover|in addition to this|additionally)\b/gi,
                    /\b(in conclusion|to conclude|in summary)\b/gi,
                    /\b(comprehensive analysis|thorough analysis|in-depth analysis)\b/gi,
                    /\b(significant implications|important implications)\b/gi,
                    /\b(robust framework|comprehensive framework)\b/gi,
                    /\b(utilize|utilizes|utilizing)\b/gi,
                    /\b(facilitate|facilitates|facilitating)\b/gi,
                    /\b(substantial|considerable|extensive)\b/gi,
                    /\b(various|numerous|myriad)\b/gi,
                    /\b(plethora|multifaceted|holistic)\b/gi,
                    
                    // Academic AI sentence starters
                    /\b(this study aims to|this research seeks to|the present study)\b/gi,
                    /\b(in today's academic landscape|in the realm of)\b/gi,
                    /\b(one cannot overstate|it cannot be denied)\b/gi,
                    /\b(suffice it to say|needless to say)\b/gi,
                    
                    // Repetitive academic transitions
                    /\b(building upon this|expanding on this notion)\b/gi,
                    /\b(it is evident that|it is clear that|it becomes apparent)\b/gi,
                    /\b(serves to highlight|serves to demonstrate)\b/gi,
                    /\b(warrants further investigation|merits consideration)\b/gi
                ];
                
                let patternCount = 0;
                academicAIPatterns.forEach(pattern => {
                    const matches = text.match(pattern);
                    if (matches) patternCount += matches.length;
                });
                
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                return Math.min((patternCount / sentences.length) * 100, 100);
            }

            static calculateAcademicComplexity(text) {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const words = text.split(/\s+/).filter(w => w.length > 0);
                
                // Count academic indicators
                const citations = (text.match(/\([^)]*\d{4}[^)]*\)/g) || []).length;
                const longWords = words.filter(word => word.length > 8).length;
                const academicTerms = words.filter(word => 
                    /^(analy|theor|method|research|stud|investig|examin|demonstrat|eviden|signific|import)/i.test(word)
                ).length;
                
                if (sentences.length === 0 || words.length === 0) return 0;
                
                const avgWordsPerSentence = words.length / sentences.length;
                const complexityScore = (
                    (avgWordsPerSentence / 25) * 30 +
                    (longWords / words.length) * 40 +
                    (academicTerms / words.length) * 20 +
                    (citations / sentences.length) * 10
                ) * 100;
                
                return Math.min(complexityScore, 100);
            }

            static suggestAcademicImprovements(text) {
                const improvements = [];
                
                // Check for AI patterns
                const aiScore = this.detectAcademicAIPatterns(text);
                if (aiScore > 20) {
                    improvements.push("High AI pattern detection - consider more natural academic phrasing");
                }
                
                // Check sentence variety
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const avgLength = sentences.reduce((sum, s) => sum + s.split(/\s+/).length, 0) / sentences.length;
                
                if (avgLength > 30) {
                    improvements.push("Consider breaking up some longer sentences for better readability");
                } else if (avgLength < 15) {
                    improvements.push("Consider combining some shorter sentences for better academic flow");
                }
                
                return improvements;
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            const humanizer = new TextHumanizer();
            
            // Add enhanced features
            const inputText = document.getElementById('inputText');
            const outputText = document.getElementById('outputText');
            
            // Real-time academic analysis
            inputText.addEventListener('input', () => {
                const text = inputText.value;
                if (text.length > 500) {
                    const aiScore = AcademicTextAnalyzer.detectAcademicAIPatterns(text);
                    const complexityScore = AcademicTextAnalyzer.calculateAcademicComplexity(text);
                    const improvements = AcademicTextAnalyzer.suggestAcademicImprovements(text);
                    
                    console.log(`Academic AI Pattern Score: ${aiScore.toFixed(1)}%`);
                    console.log(`Academic Complexity Score: ${complexityScore.toFixed(1)}`);
                    if (improvements.length > 0) {
                        console.log('Academic Suggestions:', improvements);
                    }
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'Enter':
                            e.preventDefault();
                            humanizer.humanizeText();
                            break;
                        case 'k':
                            e.preventDefault();
                            humanizer.clearAll();
                            break;
                    }
                }
            });
            
            // Auto-save to local storage (remembering the note about not using localStorage in artifacts)
            // This would be implemented in a real environment
            
            // Add tooltips for better UX
            const addTooltip = (element, text) => {
                element.setAttribute('title', text);
            };
            
            addTooltip(document.getElementById('multiPass'), 'Process the text multiple times for better humanization');
            addTooltip(document.getElementById('humanizationLevel'), 'Choose how aggressively to modify the text');
            addTooltip(document.getElementById('writingStyle'), 'Select the tone and style for the output');
        });

        // Service Worker for offline functionality (would be implemented separately)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // navigator.serviceWorker.register('/sw.js'); // Uncomment in production
            });
        }
    </script>
</body>
</html>
